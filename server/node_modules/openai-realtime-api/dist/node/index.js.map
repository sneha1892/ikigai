{"version":3,"sources":["../../src/node/relay-server.ts","../../src/utils.ts"],"sourcesContent":["import type { IncomingMessage } from 'node:http'\n\nimport { type WebSocket, WebSocketServer } from 'ws'\n\nimport type { RealtimeClient } from '../client'\nimport type { RealtimeClientEvents } from '../events'\nimport { assert, getEnv } from '../utils'\n\n/**\n * Simple Node.js relay server for the OpenAI Realtime API.\n *\n * @example\n *\n * ```ts\n * import { RealtimeClient } from 'openai-realtime-api'\n * import { RealtimeRelay } from 'openai-realtime-api/node'\n *\n * const client = new RealtimeClient({ relay: true })\n * const relay = new RealtimeRelay({ client })\n * relay.listen(8081)\n * ```\n */\nexport class RealtimeRelay {\n  readonly client: RealtimeClient\n  wss?: WebSocketServer\n\n  constructor({ client }: { client: RealtimeClient }) {\n    assert(\n      client.relay,\n      'RealtimeRelay client must have the \"relay\" option set'\n    )\n    assert(\n      client.realtime.apiKey,\n      'RealtimeRelay client must have an API key set'\n    )\n\n    this.client = client\n  }\n\n  /**\n   * Creates a `WebSocketServer` and begins listening for connections.\n   *\n   * @param port Port to listen on; defaults to the PORT environment variable or 8081.\n   */\n  listen(port?: number) {\n    assert(!this.wss, 'RealtimeRelay is already listening')\n\n    if (!port) {\n      port = Number.parseInt(getEnv('PORT') ?? '8081')\n      assert(!Number.isNaN(port), `Invalid port: ${port}`)\n    }\n\n    this.wss = new WebSocketServer({ port })\n    this.wss.on('connection', this._connectionHandler.bind(this))\n\n    this._info(`Listening on ws://localhost:${port}`)\n  }\n\n  /**\n   * Closes the WebSocket server.\n   */\n  close() {\n    this.wss?.close()\n    this.wss = undefined\n  }\n\n  protected async _connectionHandler(ws: WebSocket, req: IncomingMessage) {\n    if (!req.url) {\n      this._error('No URL provided, closing connection.')\n      ws.close()\n      return\n    }\n\n    const url = new URL(req.url, `http://${req.headers.host}`)\n    const pathname = url.pathname\n\n    if (pathname !== '/') {\n      this._error(`Invalid pathname: \"${pathname}\"`)\n      ws.close()\n      return\n    }\n\n    // Relay: OpenAI server events -> browser\n    this.client.realtime.on('server.*', (event) => {\n      this._debug(`Relaying \"${event.type}\" to client`)\n      ws.send(JSON.stringify(event))\n    })\n    this.client.realtime.on('close', () => ws.close())\n\n    // Relay: browser events -> OpenAI server\n    // We need to queue data waiting for the OpenAI connection\n    const messageQueue: string[] = []\n    const messageHandler = (data: string) => {\n      try {\n        const event = JSON.parse(data) as RealtimeClientEvents.ClientEvent\n        this._debug(`Relaying \"${event.type}\" to server`)\n        this.client.realtime.send(event.type, event)\n      } catch (err: any) {\n        this._error(`Error parsing event from client: ${data}`, err.message)\n      }\n    }\n\n    ws.on('message', (data) => {\n      if (!this.client.isConnected) {\n        messageQueue.push(data.toString())\n      } else {\n        messageHandler(data.toString())\n      }\n    })\n    ws.on('close', () => this.client.disconnect())\n\n    // Connect to OpenAI Realtime API\n    try {\n      this._info('Connecting to server...', this.client.realtime.url)\n      await this.client.connect()\n    } catch (err: any) {\n      this._error('Error connecting to server', err.message)\n      ws.close()\n      return\n    }\n\n    this._info('Connected to server successfully', this.client.realtime.url)\n    while (messageQueue.length) {\n      messageHandler(messageQueue.shift()!)\n    }\n  }\n\n  protected _info(...args: any[]) {\n    console.log('[RealtimeRelay]', ...args)\n  }\n\n  protected _debug(...args: any[]) {\n    if (this.client.realtime.debug) {\n      console.log('[RealtimeRelay]', ...args)\n    }\n  }\n\n  protected _error(...args: any[]) {\n    console.error('[RealtimeRelay]', ...args)\n  }\n}\n","import { customAlphabet } from 'nanoid'\n\nexport const isBrowser = !!(globalThis as any).document\n\nexport function hasNativeWebSocket(): boolean {\n  return !!globalThis.WebSocket\n}\n\nexport function getEnv(name: string): string | undefined {\n  try {\n    return typeof process !== 'undefined'\n      ? // eslint-disable-next-line no-process-env\n        process.env?.[name]\n      : undefined\n  } catch {\n    return undefined\n  }\n}\n\nexport function assert(\n  value: unknown,\n  message?: string | Error\n): asserts value {\n  if (value) {\n    return\n  }\n\n  if (!message) {\n    throw new Error('Assertion failed')\n  }\n\n  throw typeof message === 'string' ? new Error(message) : message\n}\n\n/**\n * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format.\n */\nexport function floatTo16BitPCM(float32Array: Float32Array): ArrayBuffer {\n  const buffer = new ArrayBuffer(float32Array.length * 2)\n  const view = new DataView(buffer)\n  let offset = 0\n\n  for (let i = 0; i < float32Array.length; i++, offset += 2) {\n    const s = Math.max(-1, Math.min(1, float32Array[i]!))\n    view.setInt16(offset, s < 0 ? s * 0x80_00 : s * 0x7f_ff, true)\n  }\n\n  return buffer\n}\n\n/**\n * Converts a base64 string to an ArrayBuffer.\n */\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  const binaryString = atob(base64)\n  const len = binaryString.length\n  const bytes = new Uint8Array(len)\n\n  for (let i = 0; i < len; i++) {\n    // eslint-disable-next-line unicorn/prefer-code-point\n    bytes[i] = binaryString.charCodeAt(i)\n  }\n\n  return bytes.buffer\n}\n\n/**\n * Converts an ArrayBuffer, Int16Array or Float32Array to a base64 string.\n */\nexport function arrayBufferToBase64(\n  arrayBuffer: ArrayBuffer | Int16Array | Float32Array\n): string {\n  if (arrayBuffer instanceof Float32Array) {\n    arrayBuffer = floatTo16BitPCM(arrayBuffer)\n  } else if (arrayBuffer instanceof Int16Array) {\n    arrayBuffer = arrayBuffer.buffer\n  }\n\n  const bytes = new Uint8Array(arrayBuffer)\n  const chunkSize = 0x80_00 // 32KB chunk size\n  let binary = ''\n\n  for (let i = 0; i < bytes.length; i += chunkSize) {\n    const chunk = bytes.subarray(i, i + chunkSize)\n    binary += String.fromCharCode.apply(null, chunk as any)\n  }\n\n  return btoa(binary)\n}\n\n/**\n * Merge two Int16Arrays from Int16Arrays or ArrayBuffers.\n */\nexport function mergeInt16Arrays(\n  left: ArrayBuffer | Int16Array,\n  right: ArrayBuffer | Int16Array\n): Int16Array {\n  if (left instanceof ArrayBuffer) {\n    left = new Int16Array(left)\n  }\n\n  if (right instanceof ArrayBuffer) {\n    right = new Int16Array(right)\n  }\n\n  if (!(left instanceof Int16Array) || !(right instanceof Int16Array)) {\n    throw new TypeError(`Both items must be Int16Array`)\n  }\n\n  const newValues = new Int16Array(left.length + right.length)\n  for (const [i, element] of left.entries()) {\n    newValues[i] = element\n  }\n\n  for (const [j, element] of right.entries()) {\n    newValues[left.length + j] = element\n  }\n\n  return newValues\n}\n\n// base58; non-repeating chars\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\nconst generateIdImpl = customAlphabet(alphabet, 21)\n\n/**\n * Generates an id to send with events and messages.\n */\nexport function generateId(prefix: string, size = 21): string {\n  const id = generateIdImpl(size)\n  return `${prefix}${id}`\n}\n\nexport const sleep = (t: number) =>\n  new Promise<void>((r) => setTimeout(() => r(), t))\n\n/**\n * Trims an event's content for debugging purposes to make logs easier to read.\n */\nexport function trimDebugEvent(\n  event?: any,\n  {\n    maxLimit = 200\n  }: {\n    maxLimit?: number\n  } = {}\n): any {\n  if (!event) return event\n\n  const e = structuredClone(event)\n\n  if (e.item?.content?.find((c: any) => c.audio)) {\n    e.item.content = e.item.content.map(({ audio, c }: any) => {\n      if (audio) {\n        return {\n          ...c,\n          audio: '<base64 redacted...>'\n        }\n      } else {\n        return c\n      }\n    })\n  }\n\n  if (e.audio) {\n    e.audio = '<audio redacted...>'\n  }\n\n  if (e.delta?.length > maxLimit) {\n    e.delta = e.delta.slice(0, maxLimit) + '... (truncated)'\n  }\n\n  return e\n}\n"],"mappings":"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","names":[]}