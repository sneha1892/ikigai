{"version":3,"sources":["../src/event-handler.ts","../src/utils.ts","../src/api.ts","../src/conversation.ts","../src/client.ts"],"sourcesContent":["import type { Event } from './events'\nimport type { MaybePromise } from './types'\n\nexport type EventHandlerCallback<EventData> = (\n  event: EventData\n) => MaybePromise<unknown>\n\n/**\n * Basic event handler.\n */\nexport class RealtimeEventHandler<\n  EventType extends string = string,\n  EventData extends Event = Event,\n  EventMap extends Record<EventType, EventData> = Record<EventType, EventData>\n> {\n  eventHandlers: Record<EventType, EventHandlerCallback<EventData>[]> =\n    {} as Record<EventType, EventHandlerCallback<EventData>[]>\n\n  /**\n   * Clears all event handlers.\n   */\n  clearEventHandlers() {\n    this.eventHandlers = {} as Record<\n      EventType,\n      EventHandlerCallback<EventData>[]\n    >\n  }\n\n  /**\n   * Adds a listener for a specific event.\n   */\n  on<\n    E extends EventType,\n    D extends EventData = EventMap[E] extends EventData\n      ? EventMap[E]\n      : EventData\n  >(eventName: E, callback: EventHandlerCallback<D>) {\n    this.eventHandlers[eventName] = this.eventHandlers[eventName] || []\n    this.eventHandlers[eventName].push(\n      callback as EventHandlerCallback<EventData>\n    )\n  }\n\n  /**\n   * Adds a listener for a single occurrence of an event.\n   */\n  once<\n    E extends EventType,\n    D extends EventData = EventMap[E] extends EventData\n      ? EventMap[E]\n      : EventData\n  >(eventName: E, callback: EventHandlerCallback<D>) {\n    const onceCallback = (event: D) => {\n      this.off(eventName, onceCallback)\n      return callback(event)\n    }\n    this.on(eventName, onceCallback)\n  }\n\n  /**\n   * Removes a listener for an event.\n   * Calling without a callback will remove all listeners for the event.\n   */\n  off<\n    E extends EventType,\n    D extends EventData = EventMap[E] extends EventData\n      ? EventMap[E]\n      : EventData\n  >(eventName: E, callback?: EventHandlerCallback<D>) {\n    const handlers = this.eventHandlers[eventName] || []\n    if (callback) {\n      const index = handlers.indexOf(\n        callback as EventHandlerCallback<EventData>\n      )\n      if (index < 0) {\n        throw new Error(\n          `Could not turn off specified event listener for \"${eventName}\": not found as a listener`\n        )\n      }\n\n      handlers.splice(index, 1)\n    } else {\n      delete this.eventHandlers[eventName]\n    }\n  }\n\n  /**\n   * Waits for next event of a specific type and returns the payload.\n   */\n  async waitForNext<\n    E extends EventType,\n    D extends EventData = EventMap[E] extends EventData\n      ? EventMap[E]\n      : EventData\n  >(eventName: E, { timeoutMs }: { timeoutMs?: number } = {}): Promise<D> {\n    return new Promise<D>((resolve, reject) => {\n      this.once(eventName, resolve as any)\n\n      if (timeoutMs !== undefined) {\n        setTimeout(\n          () => reject(new Error(`Timeout waiting for \"${eventName}\"`)),\n          timeoutMs\n        )\n      }\n    })\n  }\n\n  /**\n   * Executes all events handlers in the order they were added.\n   */\n  dispatch<\n    E extends EventType,\n    D extends EventData = EventMap[E] extends EventData\n      ? EventMap[E]\n      : EventData\n  >(eventName: E, event: D) {\n    const handlers = this.eventHandlers[eventName] || []\n    for (const handler of handlers) {\n      handler(event)\n    }\n  }\n}\n","import { customAlphabet } from 'nanoid'\n\nexport const isBrowser = !!(globalThis as any).document\n\nexport function hasNativeWebSocket(): boolean {\n  return !!globalThis.WebSocket\n}\n\nexport function getEnv(name: string): string | undefined {\n  try {\n    return typeof process !== 'undefined'\n      ? // eslint-disable-next-line no-process-env\n        process.env?.[name]\n      : undefined\n  } catch {\n    return undefined\n  }\n}\n\nexport function assert(\n  value: unknown,\n  message?: string | Error\n): asserts value {\n  if (value) {\n    return\n  }\n\n  if (!message) {\n    throw new Error('Assertion failed')\n  }\n\n  throw typeof message === 'string' ? new Error(message) : message\n}\n\n/**\n * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format.\n */\nexport function floatTo16BitPCM(float32Array: Float32Array): ArrayBuffer {\n  const buffer = new ArrayBuffer(float32Array.length * 2)\n  const view = new DataView(buffer)\n  let offset = 0\n\n  for (let i = 0; i < float32Array.length; i++, offset += 2) {\n    const s = Math.max(-1, Math.min(1, float32Array[i]!))\n    view.setInt16(offset, s < 0 ? s * 0x80_00 : s * 0x7f_ff, true)\n  }\n\n  return buffer\n}\n\n/**\n * Converts a base64 string to an ArrayBuffer.\n */\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  const binaryString = atob(base64)\n  const len = binaryString.length\n  const bytes = new Uint8Array(len)\n\n  for (let i = 0; i < len; i++) {\n    // eslint-disable-next-line unicorn/prefer-code-point\n    bytes[i] = binaryString.charCodeAt(i)\n  }\n\n  return bytes.buffer\n}\n\n/**\n * Converts an ArrayBuffer, Int16Array or Float32Array to a base64 string.\n */\nexport function arrayBufferToBase64(\n  arrayBuffer: ArrayBuffer | Int16Array | Float32Array\n): string {\n  if (arrayBuffer instanceof Float32Array) {\n    arrayBuffer = floatTo16BitPCM(arrayBuffer)\n  } else if (arrayBuffer instanceof Int16Array) {\n    arrayBuffer = arrayBuffer.buffer\n  }\n\n  const bytes = new Uint8Array(arrayBuffer)\n  const chunkSize = 0x80_00 // 32KB chunk size\n  let binary = ''\n\n  for (let i = 0; i < bytes.length; i += chunkSize) {\n    const chunk = bytes.subarray(i, i + chunkSize)\n    binary += String.fromCharCode.apply(null, chunk as any)\n  }\n\n  return btoa(binary)\n}\n\n/**\n * Merge two Int16Arrays from Int16Arrays or ArrayBuffers.\n */\nexport function mergeInt16Arrays(\n  left: ArrayBuffer | Int16Array,\n  right: ArrayBuffer | Int16Array\n): Int16Array {\n  if (left instanceof ArrayBuffer) {\n    left = new Int16Array(left)\n  }\n\n  if (right instanceof ArrayBuffer) {\n    right = new Int16Array(right)\n  }\n\n  if (!(left instanceof Int16Array) || !(right instanceof Int16Array)) {\n    throw new TypeError(`Both items must be Int16Array`)\n  }\n\n  const newValues = new Int16Array(left.length + right.length)\n  for (const [i, element] of left.entries()) {\n    newValues[i] = element\n  }\n\n  for (const [j, element] of right.entries()) {\n    newValues[left.length + j] = element\n  }\n\n  return newValues\n}\n\n// base58; non-repeating chars\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\nconst generateIdImpl = customAlphabet(alphabet, 21)\n\n/**\n * Generates an id to send with events and messages.\n */\nexport function generateId(prefix: string, size = 21): string {\n  const id = generateIdImpl(size)\n  return `${prefix}${id}`\n}\n\nexport const sleep = (t: number) =>\n  new Promise<void>((r) => setTimeout(() => r(), t))\n\n/**\n * Trims an event's content for debugging purposes to make logs easier to read.\n */\nexport function trimDebugEvent(\n  event?: any,\n  {\n    maxLimit = 200\n  }: {\n    maxLimit?: number\n  } = {}\n): any {\n  if (!event) return event\n\n  const e = structuredClone(event)\n\n  if (e.item?.content?.find((c: any) => c.audio)) {\n    e.item.content = e.item.content.map(({ audio, c }: any) => {\n      if (audio) {\n        return {\n          ...c,\n          audio: '<base64 redacted...>'\n        }\n      } else {\n        return c\n      }\n    })\n  }\n\n  if (e.audio) {\n    e.audio = '<audio redacted...>'\n  }\n\n  if (e.delta?.length > maxLimit) {\n    e.delta = e.delta.slice(0, maxLimit) + '... (truncated)'\n  }\n\n  return e\n}\n","import type { ClientRequest } from 'node:http'\n\nimport type { WebSocket as WS } from 'ws'\n\nimport type {\n  Event,\n  RealtimeClientEvents,\n  RealtimeServerEvents\n} from './events'\nimport { RealtimeEventHandler } from './event-handler'\nimport {\n  generateId,\n  getEnv,\n  hasNativeWebSocket,\n  isBrowser,\n  trimDebugEvent\n} from './utils'\n\n/**\n * The RealtimeAPI class handles low-level communication with the OpenAI\n * Realtime API via WebSockets.\n */\nexport class RealtimeAPI extends RealtimeEventHandler<\n  | RealtimeClientEvents.EventType\n  | RealtimeServerEvents.EventType\n  | 'close'\n  | `client.${RealtimeClientEvents.EventType}`\n  | `server.${RealtimeServerEvents.EventType}`\n  | 'client.*'\n  | 'server.*',\n  Event,\n  RealtimeClientEvents.EventMap &\n    RealtimeServerEvents.EventMap &\n    RealtimeClientEvents.PrefixedEventMap &\n    RealtimeServerEvents.PrefixedEventMap & {\n      'client.*': RealtimeClientEvents.ClientEvent\n    } & {\n      'server.*': RealtimeServerEvents.ServerEvent\n    } & {\n      close: { type: 'close'; error: boolean }\n    }\n> {\n  readonly model: string\n  readonly url: string\n  readonly apiKey?: string\n  readonly debug: boolean\n  ws?: WebSocket | WS\n\n  /**\n   * Creates a new RealtimeAPI instance.\n   */\n  constructor({\n    model = 'gpt-4o-realtime-preview-2024-10-01',\n    url = 'wss://api.openai.com/v1/realtime',\n    apiKey = getEnv('OPENAI_API_KEY'),\n    dangerouslyAllowAPIKeyInBrowser,\n    debug\n  }: {\n    model?: string\n    url?: string\n    apiKey?: string\n    dangerouslyAllowAPIKeyInBrowser?: boolean\n    debug?: boolean\n  } = {}) {\n    super()\n\n    this.model = model\n    this.url = url\n    this.apiKey = apiKey\n    this.debug = !!debug\n\n    if (isBrowser && this.apiKey) {\n      if (!dangerouslyAllowAPIKeyInBrowser) {\n        throw new Error(\n          'Unable to provide API key in the browser without \"dangerouslyAllowAPIKeyInBrowser\" set to true'\n        )\n      }\n    }\n  }\n\n  /**\n   * Whether or not the WebSocket is connected.\n   */\n  get isConnected(): boolean {\n    return !!this.ws\n  }\n\n  /**\n   * Connects to Realtime API WebSocket Server.\n   */\n  async connect() {\n    if (this.isConnected) {\n      return\n    }\n\n    if (!this.apiKey && !isBrowser) {\n      console.warn(`No apiKey provided for connection to \"${this.url}\"`)\n    }\n\n    const url = new URL(this.url)\n    url.searchParams.set('model', this.model)\n\n    if (hasNativeWebSocket()) {\n      if (isBrowser && this.apiKey) {\n        console.warn(\n          'Warning: Connecting using API key in the browser, this is not recommended'\n        )\n      }\n\n      const ws = new WebSocket(\n        url.toString(),\n        [\n          'realtime',\n          this.apiKey ? `openai-insecure-api-key.${this.apiKey}` : undefined,\n          'openai-beta.realtime-v1'\n        ].filter(Boolean)\n      )\n\n      ws.addEventListener('message', (event) => {\n        const message: any = JSON.parse(event.data)\n        this.receive(message.type, message)\n      })\n\n      return new Promise((resolve, reject) => {\n        const connectionErrorHandler = () => {\n          this.disconnect(ws)\n          reject(new Error(`Could not connect to \"${this.url}\"`))\n        }\n\n        ws.addEventListener('error', connectionErrorHandler)\n        ws.addEventListener('open', () => {\n          this._log(`Connected to \"${this.url}\"`)\n\n          ws.removeEventListener('error', connectionErrorHandler)\n          ws.addEventListener('error', () => {\n            this.disconnect(ws)\n            this._log(`Error, disconnected from \"${this.url}\"`)\n            this.dispatch('close', { type: 'close', error: true })\n          })\n\n          ws.addEventListener('close', () => {\n            this.disconnect(ws)\n            this._log(`Disconnected from \"${this.url}\"`)\n            this.dispatch('close', { type: 'close', error: false })\n          })\n\n          this.ws = ws\n          resolve(true)\n        })\n      })\n    } else {\n      // Node.js\n      const wsModule = await import('ws')\n      const ws: WS = new wsModule.WebSocket(url.toString(), [], {\n        // Add auth headers\n        finishRequest: (request: ClientRequest) => {\n          request.setHeader('OpenAI-Beta', 'realtime=v1')\n\n          if (this.apiKey) {\n            request.setHeader('Authorization', `Bearer ${this.apiKey}`)\n\n            // Needed for Azure OpenAI\n            request.setHeader('api-key', this.apiKey)\n          }\n\n          request.end()\n        }\n        // TODO: this `any` is a workaround for `@types/ws` being out-of-date.\n      } as any)\n\n      ws.on('message', (data) => {\n        const message: any = JSON.parse(data.toString())\n        this.receive(message.type, message)\n      })\n\n      return new Promise<void>((resolve, reject) => {\n        const connectionErrorHandler = () => {\n          this.disconnect(ws)\n          reject(new Error(`Could not connect to \"${this.url}\"`))\n        }\n\n        ws.on('error', connectionErrorHandler)\n        ws.on('open', () => {\n          this._log(`Connected to \"${this.url}\"`)\n\n          ws.removeListener('error', connectionErrorHandler)\n          ws.on('error', () => {\n            this._log(`Error, disconnected from \"${this.url}\"`)\n            this.disconnect(ws)\n            this.dispatch('close', { type: 'close', error: true })\n          })\n\n          ws.on('close', () => {\n            this.disconnect(ws)\n            this._log(`Disconnected from \"${this.url}\"`)\n            this.dispatch('close', { type: 'close', error: false })\n          })\n\n          this.ws = ws\n          resolve()\n        })\n      })\n    }\n  }\n\n  /**\n   * Disconnects from the Realtime API server.\n   */\n  disconnect(ws?: WebSocket | WS) {\n    if (this.ws && (!ws || this.ws === ws)) {\n      this.ws?.close()\n      this.ws = undefined\n    }\n  }\n\n  /**\n   * Receives an event from WebSocket and dispatches related events.\n   */\n  receive<\n    E extends RealtimeServerEvents.EventType,\n    D extends\n      RealtimeServerEvents.ServerEvent = RealtimeServerEvents.EventMap[E] extends RealtimeServerEvents.ServerEvent\n      ? RealtimeServerEvents.EventMap[E]\n      : RealtimeServerEvents.ServerEvent\n  >(eventName: E, event: D) {\n    this._log('received:', eventName, event)\n    this.dispatch(eventName, event)\n    this.dispatch(`server.${eventName}`, event)\n    this.dispatch('server.*', event)\n  }\n\n  /**\n   * Sends an event to the underlying WebSocket and dispatches related events.\n   */\n  send<\n    E extends RealtimeClientEvents.EventType,\n    D extends\n      RealtimeClientEvents.ClientEvent = RealtimeClientEvents.EventMap[E] extends RealtimeClientEvents.ClientEvent\n      ? RealtimeClientEvents.EventMap[E]\n      : RealtimeClientEvents.ClientEvent\n  >(eventName: E, data: Omit<D, 'type'> = {} as any) {\n    if (!this.isConnected) {\n      throw new Error(`RealtimeAPI is not connected`)\n    }\n    data = data || {}\n    if (typeof data !== 'object') {\n      throw new TypeError(`data must be an object`)\n    }\n\n    const event = {\n      event_id: generateId('evt_'),\n      type: eventName,\n      ...data\n    }\n    this.dispatch(eventName, event)\n    this.dispatch(`client.${eventName}`, event)\n    this.dispatch('client.*', event)\n    this._log('sent:', eventName, event)\n    this.ws!.send(JSON.stringify(event))\n  }\n\n  /**\n   * Writes WebSocket logs to the console if `debug` is enabled.\n   */\n  protected _log(...args: any[]) {\n    const date = new Date().toISOString()\n    const logs = [`[Websocket/${date}]`].concat(args).map((arg) => {\n      if (typeof arg === 'object' && arg !== null) {\n        return JSON.stringify(trimDebugEvent(arg), null, 2)\n      } else {\n        return arg\n      }\n    })\n\n    if (this.debug) {\n      console.log(...logs)\n    }\n  }\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\nimport type { RealtimeServerEvents } from './events'\nimport type { EventHandlerResult, FormattedItem, Realtime } from './types'\nimport { assert, base64ToArrayBuffer, mergeInt16Arrays } from './utils'\n\n/**\n * RealtimeConversation holds conversation history and performs event\n * validation for RealtimeAPI.\n */\nexport class RealtimeConversation {\n  readonly defaultFrequency = 24_000 // 24,000 Hz\n\n  readonly frequency: number\n  readonly debug: boolean\n\n  itemLookup: Record<string, FormattedItem> = {}\n  items: FormattedItem[] = []\n  responseLookup: Record<string, Realtime.Response> = {}\n  responses: Realtime.Response[] = []\n  queuedSpeechItems: Record<\n    string,\n    { audio_start_ms: number; audio_end_ms?: number; audio?: Int16Array }\n  > = {}\n  queuedTranscriptItems: Record<string, { transcript: string }> = {}\n  queuedInputAudio?: Int16Array\n\n  constructor({\n    frequency = this.defaultFrequency,\n    debug = false\n  }: {\n    frequency?: number\n    debug?: boolean\n  } = {}) {\n    // Default to 24,000 Hz if not provided\n    if (frequency === undefined) {\n      frequency = this.defaultFrequency\n    }\n    assert(frequency > 0, `Invalid frequency: ${frequency}`)\n\n    this.frequency = frequency\n    this.debug = debug\n\n    this.clear()\n  }\n\n  /**\n   * Clears the conversation history and resets to defaults.\n   */\n  clear() {\n    this.itemLookup = {}\n    this.items = []\n    this.responseLookup = {}\n    this.responses = []\n    this.queuedSpeechItems = {}\n    this.queuedTranscriptItems = {}\n    this.queuedInputAudio = undefined\n  }\n\n  /**\n   * Queue input audio for manual speech event.\n   */\n  queueInputAudio(inputAudio: Int16Array) {\n    this.queuedInputAudio = inputAudio\n  }\n\n  /**\n   * Process an event from the WebSocket server and compose items.\n   */\n  processEvent(\n    event: RealtimeServerEvents.ServerEvent,\n    ...args: any[]\n  ): EventHandlerResult {\n    assert(event.event_id, `Missing \"event_id\" on event`)\n    assert(event.type, `Missing \"type\" on event`)\n\n    const eventProcessor = this.EventProcessors[event.type]\n    assert(eventProcessor, `Missing event processor for \"${event.type}\"`)\n\n    try {\n      return eventProcessor.call(this, event as any, ...args)\n    } catch (err: any) {\n      if (this.debug) {\n        console.error(\n          `Error processing event \"${event.type}\":`,\n          err.message,\n          event\n        )\n      }\n\n      return {}\n    }\n  }\n\n  /**\n   * Retrieves an item by ID.\n   */\n  getItem(id: string): FormattedItem | undefined {\n    return this.itemLookup[id]\n  }\n\n  /**\n   * Retrieves all items in the conversation.\n   */\n  getItems(): FormattedItem[] {\n    return this.items.slice()\n  }\n\n  /** Event handlers. */\n  EventProcessors: Partial<{\n    [K in keyof RealtimeServerEvents.EventMap]: (\n      event: RealtimeServerEvents.EventMap[K],\n      ...args: any[]\n    ) => EventHandlerResult\n  }> = {\n    'conversation.item.created': (event) => {\n      const { item } = event\n      const newItem: FormattedItem = {\n        ...structuredClone(item),\n        formatted: {\n          audio: new Int16Array(0),\n          text: '',\n          transcript: ''\n        }\n      }\n\n      if (!this.itemLookup[newItem.id]) {\n        this.itemLookup[newItem.id] = newItem\n        this.items.push(newItem)\n      }\n\n      // If we have a speech item, can populate audio\n      if (this.queuedSpeechItems[newItem.id]?.audio) {\n        newItem.formatted.audio = this.queuedSpeechItems[newItem.id]!.audio!\n        delete this.queuedSpeechItems[newItem.id] // free up some memory\n      }\n\n      // Populate formatted text if it comes out on creation\n      if (newItem.content) {\n        const textContent = newItem.content.filter(\n          (c) => c.type === 'text' || c.type === 'input_text'\n        ) as Array<Realtime.InputTextContentPart | Realtime.TextContentPart>\n\n        for (const content of textContent) {\n          newItem.formatted.text += content.text\n        }\n      }\n\n      // If we have a transcript item, can pre-populate transcript\n      if (this.queuedTranscriptItems[newItem.id]) {\n        newItem.formatted.transcript =\n          this.queuedTranscriptItems[newItem.id]!.transcript\n        delete this.queuedTranscriptItems[newItem.id]\n      }\n\n      if (newItem.type === 'message') {\n        if (newItem.role === 'user') {\n          newItem.status = 'completed'\n          if (this.queuedInputAudio) {\n            newItem.formatted.audio = this.queuedInputAudio\n            this.queuedInputAudio = undefined\n          }\n        } else {\n          newItem.status = 'in_progress'\n        }\n      } else if (newItem.type === 'function_call') {\n        newItem.formatted.tool = {\n          type: 'function',\n          name: newItem.name,\n          call_id: newItem.call_id,\n          arguments: ''\n        }\n\n        newItem.status = 'in_progress'\n      } else if (newItem.type === 'function_call_output') {\n        newItem.status = 'completed'\n        newItem.formatted.output = newItem.output\n      }\n\n      return { item: newItem }\n    },\n\n    'conversation.item.truncated': (event) => {\n      const { item_id, audio_end_ms } = event\n      const item = this.itemLookup[item_id]\n      if (!item) {\n        throw new Error(`item.truncated: Item \"${item_id}\" not found`)\n      }\n\n      const endIndex = Math.floor((audio_end_ms * this.frequency) / 1000)\n      item.formatted.transcript = ''\n      item.formatted.audio = item.formatted.audio!.slice(0, endIndex)\n\n      return { item }\n    },\n\n    'conversation.item.deleted': (event) => {\n      const { item_id } = event\n      const item = this.itemLookup[item_id]\n      if (!item) {\n        throw new Error(`item.deleted: Item \"${item_id}\" not found`)\n      }\n\n      delete this.itemLookup[item.id]\n      const index = this.items.indexOf(item)\n\n      if (index >= 0) {\n        this.items.splice(index, 1)\n      }\n\n      return { item }\n    },\n\n    'conversation.item.input_audio_transcription.completed': (event) => {\n      const { item_id, content_index, transcript } = event\n      const item = this.itemLookup[item_id]\n\n      // We use a single space to represent an empty transcript for .formatted values\n      // Otherwise it looks like no transcript provided\n      const formattedTranscript = transcript || ' '\n\n      if (!item) {\n        // We can receive transcripts in VAD mode before item.created\n        // This happens specifically when audio is empty\n        this.queuedTranscriptItems[item_id] = {\n          transcript: formattedTranscript\n        }\n\n        return {}\n      } else {\n        if (item.content[content_index]) {\n          ;(\n            item.content[content_index] as Realtime.AudioContentPart\n          ).transcript = transcript\n        }\n        item.formatted.transcript = formattedTranscript\n        return { item, delta: { transcript } }\n      }\n    },\n\n    'input_audio_buffer.speech_started': (event) => {\n      const { item_id, audio_start_ms } = event\n      const item = this.itemLookup[item_id]\n      this.queuedSpeechItems[item_id] = { audio_start_ms }\n      return { item }\n    },\n\n    'input_audio_buffer.speech_stopped': (\n      event,\n      inputAudioBuffer: Int16Array\n    ) => {\n      const { item_id, audio_end_ms } = event\n      const item = this.itemLookup[item_id]\n\n      if (!this.queuedSpeechItems[item_id]) {\n        this.queuedSpeechItems[item_id] = { audio_start_ms: audio_end_ms }\n      }\n\n      const speech = this.queuedSpeechItems[item_id]\n      assert(speech, `Speech item not found for \"${item_id}\"`)\n      speech.audio_end_ms = audio_end_ms\n\n      if (inputAudioBuffer) {\n        const startIndex = Math.floor(\n          (speech.audio_start_ms * this.frequency) / 1000\n        )\n        const endIndex = Math.floor(\n          (speech.audio_end_ms * this.frequency) / 1000\n        )\n\n        speech.audio = inputAudioBuffer.slice(startIndex, endIndex)\n      }\n\n      return { item }\n    },\n\n    'response.created': (event) => {\n      const { response } = event\n\n      if (!this.responseLookup[response.id]) {\n        this.responseLookup[response.id] = response\n        this.responses.push(response)\n      }\n\n      return { response }\n    },\n\n    'response.output_item.added': (event) => {\n      const { response_id, item } = event\n      const response = this.responseLookup[response_id]\n\n      if (!response) {\n        throw new Error(\n          `response.output_item.added: Response \"${response_id}\" not found`\n        )\n      }\n\n      response.output.push(item)\n      return { item, response }\n    },\n\n    'response.output_item.done': (event) => {\n      const { item } = event\n      if (!item) {\n        throw new Error(`response.output_item.done: Missing \"item\"`)\n      }\n\n      const foundItem = this.itemLookup[item.id]\n      if (!foundItem) {\n        throw new Error(\n          `response.output_item.done: Item \"${item.id}\" not found`\n        )\n      }\n\n      foundItem.status = item.status\n      return { item: foundItem }\n    },\n\n    'response.content_part.added': (event) => {\n      const { item_id, part } = event\n      const item = this.itemLookup[item_id]\n      if (!item) {\n        throw new Error(\n          `response.content_part.added: Item \"${item_id}\" not found`\n        )\n      }\n\n      item.content.push(part as any)\n      return { item }\n    },\n\n    'response.audio_transcript.delta': (event) => {\n      const { item_id, content_index, delta } = event\n      const item = this.itemLookup[item_id]\n      if (!item) {\n        throw new Error(\n          `response.audio_transcript.delta: Item \"${item_id}\" not found`\n        )\n      }\n\n      ;(item.content[content_index] as Realtime.AudioContentPart).transcript +=\n        delta\n      item.formatted.transcript += delta\n\n      return { item, delta: { transcript: delta } }\n    },\n\n    'response.audio.delta': (event) => {\n      const { item_id, content_index: _, delta } = event\n      const item = this.itemLookup[item_id]\n      if (!item) {\n        throw new Error(`response.audio.delta: Item \"${item_id}\" not found`)\n      }\n\n      // This never gets renderered; we care about the formatted data instead.\n      // (item.content[content_index] as Realtime.AudioContentPart)!.audio += delta;\n\n      const arrayBuffer = base64ToArrayBuffer(delta)\n      const appendValues = new Int16Array(arrayBuffer)\n      item.formatted.audio = mergeInt16Arrays(\n        item.formatted.audio,\n        appendValues\n      )\n\n      return { item, delta: { audio: appendValues } }\n    },\n\n    'response.text.delta': (event) => {\n      const { item_id, content_index, delta } = event\n      const item = this.itemLookup[item_id]\n      if (!item) {\n        throw new Error(`response.text.delta: Item \"${item_id}\" not found`)\n      }\n\n      ;(item.content[content_index] as Realtime.TextContentPart).text += delta\n      item.formatted.text += delta\n\n      return { item, delta: { text: delta } }\n    },\n\n    'response.function_call_arguments.delta': (event) => {\n      const { item_id, delta } = event\n      const item = this.itemLookup[item_id]\n      if (!item) {\n        throw new Error(\n          `response.function_call_arguments.delta: Item \"${item_id}\" not found`\n        )\n      }\n\n      ;(item as Realtime.FunctionCallItem).arguments += delta\n      item.formatted.tool!.arguments += delta\n\n      return { item, delta: { arguments: delta } }\n    }\n  }\n}\n","import type {\n  Event,\n  RealtimeClientEvents,\n  RealtimeCustomEvents,\n  RealtimeServerEvents\n} from './events'\nimport type {\n  EventHandlerResult,\n  FormattedTool,\n  Realtime,\n  ToolHandler\n} from './types'\nimport { RealtimeAPI } from './api'\nimport { RealtimeConversation } from './conversation'\nimport { RealtimeEventHandler } from './event-handler'\nimport { arrayBufferToBase64, assert, mergeInt16Arrays, sleep } from './utils'\n\n/**\n * The RealtimeClient class is the main interface for interacting with the\n * OpenAI Realtime API. It handles connection, configuration, conversation\n * updates, and server event handling.\n */\nexport class RealtimeClient extends RealtimeEventHandler<\n  | RealtimeClientEvents.EventType\n  | RealtimeServerEvents.EventType\n  | RealtimeCustomEvents.EventType,\n  Event,\n  RealtimeClientEvents.EventMap &\n    RealtimeServerEvents.EventMap &\n    RealtimeCustomEvents.EventMap\n> {\n  readonly defaultSessionConfig: Realtime.SessionConfig\n  sessionConfig: Realtime.SessionConfig\n\n  readonly relay: boolean\n\n  realtime: RealtimeAPI\n  conversation: RealtimeConversation\n\n  inputAudioBuffer: Int16Array\n  sessionCreated: boolean\n  tools: Record<\n    string,\n    {\n      definition: Realtime.ToolDefinition\n      handler: ToolHandler\n    }\n  >\n\n  constructor({\n    sessionConfig,\n    relay = false,\n    ...apiParams\n  }: {\n    sessionConfig?: Partial<Omit<Realtime.SessionConfig, 'tools'>>\n    apiKey?: string\n    model?: string\n    url?: string\n    dangerouslyAllowAPIKeyInBrowser?: boolean\n    debug?: boolean\n    /**\n     * Relay mode disables tool use, since it will be the responsibility of the\n     * upstream client to handle tool calls.\n     */\n    relay?: boolean\n  } = {}) {\n    super()\n\n    this.defaultSessionConfig = {\n      modalities: ['text', 'audio'],\n      voice: 'alloy',\n      input_audio_format: 'pcm16',\n      output_audio_format: 'pcm16',\n      input_audio_transcription: {\n        model: 'whisper-1'\n      },\n      turn_detection: null,\n      // turn_detection: {\n      //   type: 'server_vad',\n      //   threshold: 0.5,\n      //   prefix_padding_ms: 300,\n      //   silence_duration_ms: 500\n      // },\n      tools: [],\n      tool_choice: 'auto',\n      temperature: 0.8,\n      max_response_output_tokens: 4096,\n      ...sessionConfig\n    }\n    this.sessionConfig = {}\n    this.sessionCreated = false\n    this.tools = {}\n    this.inputAudioBuffer = new Int16Array(0)\n    this.relay = !!relay\n\n    this.realtime = new RealtimeAPI(apiParams)\n    this.conversation = new RealtimeConversation({ debug: apiParams.debug })\n\n    this._resetConfig()\n    this._addAPIEventHandlers()\n  }\n\n  /**\n   * Resets sessionConfig and conversation to defaults.\n   */\n  protected _resetConfig() {\n    this.sessionCreated = false\n    this.tools = {}\n    this.sessionConfig = structuredClone(this.defaultSessionConfig)\n    this.inputAudioBuffer = new Int16Array(0)\n  }\n\n  /**\n   * Sets up event handlers for a fully-functional application control flow.\n   */\n  protected _addAPIEventHandlers() {\n    // Event Logging handlers\n    this.realtime.on('client.*', (event: any) => {\n      this.dispatch('realtime.event', {\n        type: 'realtime.event',\n        time: new Date().toISOString(),\n        source: 'client',\n        event\n      })\n    })\n\n    this.realtime.on('server.*', (event: RealtimeServerEvents.ServerEvent) => {\n      this.dispatch('realtime.event', {\n        type: 'realtime.event',\n        time: new Date().toISOString(),\n        source: 'server',\n        event\n      })\n    })\n\n    // Handles session created event\n    this.realtime.on('server.session.created', () => {\n      this.sessionCreated = true\n    })\n\n    // Setup for application control flow\n    const handler = (event: any, ...args: any[]): EventHandlerResult => {\n      if (!this.isConnected) return {}\n      return this.conversation.processEvent(event, ...args)\n    }\n\n    const handlerWithDispatch = (event: any, ...args: any[]) => {\n      const res = handler(event, ...args)\n\n      if (res.item) {\n        // FIXME: This is only here because `item.input_audio_transcription.completed`\n        // can fire before `item.created`, resulting in empty item. This happens in\n        // VAD mode with empty audio.\n        this.dispatch('conversation.updated', {\n          type: 'conversation.updated',\n          ...res\n        })\n      }\n\n      return res\n    }\n\n    const callTool = async (tool: FormattedTool) => {\n      // In relay mode, we don't attempt to call tools. That is the\n      // responsibility of the upstream client.\n      if (this.isRelay) return\n\n      try {\n        const jsonArguments = JSON.parse(tool.arguments)\n        const toolConfig = this.tools[tool.name]\n        if (!toolConfig) {\n          console.warn(`Tool \"${tool.name}\" not found`)\n          return\n        }\n\n        const result = await Promise.resolve(toolConfig.handler(jsonArguments))\n        this.realtime.send('conversation.item.create', {\n          item: {\n            type: 'function_call_output',\n            call_id: tool.call_id,\n            output: JSON.stringify(result)\n          }\n        })\n      } catch (err: any) {\n        console.warn(`Error calling tool \"${tool.name}\":`, err.message)\n\n        this.realtime.send('conversation.item.create', {\n          item: {\n            type: 'function_call_output',\n            call_id: tool.call_id,\n            output: JSON.stringify({ error: err.message })\n          }\n        })\n      }\n\n      this.createResponse()\n    }\n\n    // Handlers to update internal conversation state\n    this.realtime.on('server.response.created', handler)\n    this.realtime.on('server.response.output_item.added', handler)\n    this.realtime.on('server.response.content_part.added', handler)\n    this.realtime.on(\n      'server.input_audio_buffer.speech_started',\n      (event: RealtimeServerEvents.InputAudioBufferSpeechStartedEvent) => {\n        handler(event)\n        this.dispatch('conversation.interrupted', event)\n      }\n    )\n    this.realtime.on(\n      'server.input_audio_buffer.speech_stopped',\n      (event: RealtimeServerEvents.InputAudioBufferSpeechStoppedEvent) => {\n        handler(event, this.inputAudioBuffer)\n      }\n    )\n\n    // Handlers to update application state\n    this.realtime.on(\n      'server.conversation.item.created',\n      (event: RealtimeServerEvents.ConversationItemCreatedEvent) => {\n        const res = handlerWithDispatch(event)\n        if (!res.item) return\n\n        this.dispatch('conversation.item.appended', {\n          type: 'conversation.item.appended',\n          ...res\n        })\n\n        if (res.item.status === 'completed') {\n          this.dispatch('conversation.item.completed', {\n            type: 'conversation.item.completed',\n            ...res\n          })\n        }\n      }\n    )\n    this.realtime.on('server.conversation.item.truncated', handlerWithDispatch)\n    this.realtime.on('server.conversation.item.deleted', handlerWithDispatch)\n    this.realtime.on(\n      'server.conversation.item.input_audio_transcription.completed',\n      handlerWithDispatch\n    )\n    this.realtime.on(\n      'server.response.audio_transcript.delta',\n      handlerWithDispatch\n    )\n    this.realtime.on('server.response.audio.delta', handlerWithDispatch)\n    this.realtime.on('server.response.text.delta', handlerWithDispatch)\n    this.realtime.on(\n      'server.response.function_call_arguments.delta',\n      handlerWithDispatch\n    )\n    this.realtime.on(\n      'server.response.output_item.done',\n      async (event: RealtimeServerEvents.ResponseOutputItemDoneEvent) => {\n        const res = handlerWithDispatch(event)\n        if (!res.item?.formatted) return\n\n        if (res.item.status === 'completed') {\n          this.dispatch('conversation.item.completed', {\n            type: 'conversation.item.completed',\n            ...res\n          })\n        }\n\n        if (res.item.formatted.tool) {\n          callTool(res.item.formatted.tool)\n        }\n      }\n    )\n  }\n\n  /**\n   * Whether the realtime socket is connected.\n   */\n  get isConnected(): boolean {\n    return this.realtime.isConnected\n  }\n\n  /**\n   * Whether the client is in relay mode. When in relay mode, the client will\n   * not attempt to invoke tools.\n   */\n  get isRelay(): boolean {\n    return this.relay\n  }\n\n  /**\n   * Resets the client instance entirely: disconnects and clears configs.\n   */\n  reset() {\n    this.disconnect()\n    this.clearEventHandlers()\n    this.realtime.clearEventHandlers()\n    this._resetConfig()\n    this._addAPIEventHandlers()\n  }\n\n  /**\n   * Connects to the Realtime WebSocket API and updates the session config.\n   */\n  async connect() {\n    if (this.isConnected) {\n      return\n    }\n\n    await this.realtime.connect()\n    this.updateSession()\n  }\n\n  /**\n   * Waits for a session.created event to be executed before proceeding.\n   */\n  async waitForSessionCreated() {\n    assert(this.isConnected, 'Not connected, use .connect() first')\n\n    while (!this.sessionCreated) {\n      await sleep(1)\n    }\n  }\n\n  /**\n   * Disconnects from the Realtime API and clears the conversation history.\n   */\n  disconnect() {\n    this.sessionCreated = false\n    this.realtime.disconnect()\n    this.conversation.clear()\n  }\n\n  /**\n   * Gets the active turn detection mode.\n   */\n  getTurnDetectionType(): 'server_vad' | undefined {\n    return this.sessionConfig.turn_detection?.type\n  }\n\n  /**\n   * Adds a tool to the session.\n   */\n  addTool(definition: Realtime.PartialToolDefinition, handler: ToolHandler) {\n    assert(!this.isRelay, 'Unable to add tools in relay mode')\n    assert(definition?.name, 'Missing tool name in definition')\n    const { name } = definition\n\n    assert(\n      typeof handler === 'function',\n      `Tool \"${name}\" handler must be a function`\n    )\n\n    this.tools[name] = {\n      definition: {\n        type: 'function',\n        ...definition\n      },\n      handler\n    }\n    this.updateSession()\n  }\n\n  /**\n   * Removes a tool from the session.\n   */\n  removeTool(name: string) {\n    assert(!this.isRelay, 'Unable to add tools in relay mode')\n    assert(\n      this.tools[name],\n      `Tool \"${name}\" does not exist, can not be removed.`\n    )\n    delete this.tools[name]\n    this.updateSession()\n  }\n\n  /**\n   * Deletes an item.\n   */\n  deleteItem(id: string) {\n    this.realtime.send('conversation.item.delete', { item_id: id })\n  }\n\n  /**\n   * Updates session configuration.\n   *\n   * If the client is not yet connected, the session will be updated upon connection.\n   */\n  updateSession(sessionConfig: Realtime.SessionConfig = {}) {\n    const tools = Object.values(this.tools).map(({ definition }) => definition)\n\n    this.sessionConfig = {\n      ...this.sessionConfig,\n      ...sessionConfig,\n      tools\n    }\n\n    if (this.isConnected && !this.isRelay) {\n      this.realtime.send('session.update', {\n        session: structuredClone(this.sessionConfig)\n      })\n    }\n  }\n\n  /**\n   * Sends user message content and generates a response.\n   */\n  sendUserMessageContent(\n    content: Array<\n      Realtime.InputTextContentPart | Realtime.InputAudioContentPart\n    >\n  ) {\n    assert(!this.isRelay, 'Unable to send messages directly in relay mode')\n\n    if (content.length) {\n      this.realtime.send('conversation.item.create', {\n        item: {\n          type: 'message',\n          role: 'user',\n          content\n        }\n      })\n    }\n\n    this.createResponse()\n  }\n\n  /**\n   * Appends user audio to the existing audio buffer.\n   */\n  appendInputAudio(arrayBuffer: Int16Array | ArrayBuffer) {\n    assert(!this.isRelay, 'Unable to append input audio directly in relay mode')\n\n    if (arrayBuffer.byteLength > 0) {\n      this.realtime.send('input_audio_buffer.append', {\n        audio: arrayBufferToBase64(arrayBuffer)\n      })\n\n      this.inputAudioBuffer = mergeInt16Arrays(\n        this.inputAudioBuffer,\n        arrayBuffer\n      )\n    }\n  }\n\n  /**\n   * Forces the model to generate a response.\n   */\n  createResponse() {\n    assert(!this.isRelay, 'Unable to create a response directly in relay mode')\n\n    if (!this.getTurnDetectionType() && this.inputAudioBuffer.byteLength > 0) {\n      this.realtime.send('input_audio_buffer.commit')\n      this.conversation.queueInputAudio(this.inputAudioBuffer)\n      this.inputAudioBuffer = new Int16Array(0)\n    }\n\n    this.realtime.send('response.create')\n  }\n\n  /**\n   * Cancels the ongoing server generation and truncates ongoing generation, if\n   * applicable.\n   *\n   * If no id provided, will simply call `cancel_generation` command.\n   */\n  cancelResponse(\n    /** The ID of the item to cancel. */\n    id?: string,\n    /** The number of samples to truncate past for the ongoing generation. */\n    sampleCount = 0\n  ): Realtime.AssistantItem | undefined {\n    assert(!this.isRelay, 'Unable to cancel a response directly in relay mode')\n\n    if (!id) {\n      this.realtime.send('response.cancel')\n      return\n    }\n\n    const item = this.conversation.getItem(id)\n    assert(item, `Could not find item \"${id}\"`)\n    assert(\n      item.type === 'message',\n      `Can only cancelResponse messages with type \"message\"`\n    )\n    assert(\n      item.role === 'assistant',\n      `Can only cancelResponse messages with role \"assistant\"`\n    )\n\n    this.realtime.send('response.cancel')\n    const audioIndex = item.content.findIndex((c) => c.type === 'audio')\n    assert(audioIndex >= 0, `Could not find audio on item ${id} to cancel`)\n\n    this.realtime.send('conversation.item.truncate', {\n      item_id: id,\n      content_index: audioIndex,\n      audio_end_ms: Math.floor(\n        (sampleCount / this.conversation.defaultFrequency) * 1000\n      )\n    })\n\n    return item\n  }\n\n  /**\n   * Utility for waiting for the next `conversation.item.appended` event to be\n   * triggered by the server.\n   */\n  async waitForNextItem(): Promise<Realtime.Item> {\n    const event = await this.waitForNext('conversation.item.appended')\n    return event.item\n  }\n\n  /**\n   * Utility for waiting for the next `conversation.item.completed` event to be\n   * triggered by the server.\n   */\n  async waitForNextCompletedItem(): Promise<Realtime.Item> {\n    const event = await this.waitForNext('conversation.item.completed')\n    return event.item\n  }\n}\n"],"mappings":"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","names":[]}